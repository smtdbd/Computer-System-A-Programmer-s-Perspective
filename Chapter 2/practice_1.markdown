## 练习2.1
### 完成下面的数字转换
* * 将0x39A7F8转换为二进制
  * 0011 1001 1010 0111 1111 1000
* * 将二进制1100 1001 0111 1011转换为16进制
  * 0xC97B
* * 将0xD5E4C转换为二进制
  * 1101 0101 1110 0100 1100
* * 将二进制10 0110 1110 0111 1011 0101转换为16进制
  * 0x26E7B5
***
## 练习2.2
### 填写下表中的空白项，给出2的不同次幂的二进制和十六进制表示：
|n  |2^n(十进制) |2^n(十六进制)|
|:--|:----------|:------------|
|9  |512        |0x200        |
|19 |524288     |0x80000      |
|14 |16384      |0x4000       |
|16 |65536      |0x10000      |
|17 |131072     |0x20000      |
|5  |32         |0x20         |
|7  |128        |0x80         |
***
## 练习2.3
### 一个字节可以用两个十六进制数字来表示。填写下表中缺少的项，给出不同字节模式的十进制、二进制和十六进制。
|十进制|二进制|十六进制|
|:-|:-|:-|
|0|0000 0000|0x00|
|167|1010 0111|0xA7|
|62|0011 1110|0x3E|
|188|1011 1100|0xBC|
|55|0011 0111|0x37|
|136|1000 1000|0x88|
|243|1111 0011|0xF3|
|82|01010010|0x52|
|172|10101100|0xAC|
|231|11100111|0xE7|
***
## 练习2.4
### 不讲数字转换为十进制或者二进制，试着解答下面的算术题，答案要用十六进制表示。提示：只要将指向十进制加法和减法所使用的方法改成以16为基数。
* 0x503c + 0x8 = 0x5044
* 0x503c - 0x40 = 0x4ffc
* 0x503c + 64 = 0x507c
* 0x50ea - 0x503c = 0xae
***
## 练习2.5
### 思考下面对show_bytes的三次调用
```cpp
int val = 0x87654321;
byte_pointer valp = (byte_pointer)&val;
show_bytes(valp, 1);  /* A. */
show_bytes(valp, 2);  /* B. */
show_bytes(valp, 3);  /* C. */
```
指出在小端法机器和大端法机器上，每次调用的输出值。
| |小端法|大端法|
|:-|:-|:-|
|A.|21|78|
|B.|43|56|
|C.|65|43|
***
## 练习2.6
### 使用show_int和show_float，我们确定整数3510593的十六进制表示为0x00359141，而浮点数3510593.0的十六进制表示为0x4A564504
* * 写出这两个十六进制值的二进制表示   
  * 0000 0000 0011 0101 1001 0001 0100 0001
  * 0100 1010 0101 0110 0100 0101 0000 0100
* * 移动这两个二进制串的相对位置，使得它们相匹配的位数最多。有多少位相匹配？
  * ```
     00000000001101011001000101000001
       01001010010101100100010100000100
    ```
    有21位相匹配
* 串中的什么部分不相匹配？  
前后两头
***
## 练习2.7
### 下面对show_bytes的调用将输出什么结果？
```cpp
	const char *s = "abcdef";
	show_bytes((byte_pointer) s, strlen(s));
```
注意字母'a'~'z'的ASCII码为0x61~0x7A
* 输出为：" a b c d e f"，因为strlen不计算'\0'字节。
***
## 练习2.8
### 填写下标，给出位向量的布尔运算的求值结果。
|运算|结果|
|:-|:-|
|a|0110 1001|
|b|0101 0101|
|~a|1001 0110|
|~b|1010 1010|
|a & b|0100 0001|
|a \| b|0111 1101|
|a ^ b|0011 1100|
***
## 练习2.9
### 基于光源R(红),G(绿),B(蓝)的关闭(0)或打开(1),我们就能创建八种不同的颜色：
|R|G|B|颜色|
|:-|:-|:-|:-|
|0|0|0|黑色|
|0|0|1|蓝色|
|0|1|0|绿色|
|0|1|1|蓝绿色|
|1|0|0|红色|
|1|0|1|红紫色|
|1|1|0|黄色|
|1|1|1|白色|
这些颜色的每一种都能用一个长度为3的位向量来表示，我们可以对它们进行布尔运算。
* * 一种颜色的补是通过关掉打开的光源，且打开关闭的光源而形成的。那么上面列出的八种颜色的每一种的补是什么？
  * |原颜色|补颜色|
    |:-|:-|
    |黑色|白色|
    |蓝色|黄色|
    |绿色|红紫色|
    |蓝绿色|红色|
    |红色|蓝绿色|
    |红紫色|绿色|
    |黄色|蓝色|
    |白色|黑色|
* * 描述下列颜色应用布尔运算的结果：
  * 蓝色 | 绿色 = 蓝绿色
  * 黄色 & 蓝绿色 = 绿色
  * 红色 ^ 红紫色 = 蓝色
***   
## 练习2.14
### 假设x和y的字节值分别为0x66和0x39。填写下标，指明各个C表达式的字节值。
|表达式|值|
|:-|:-|
|x & y|0x20|
|x \| y|0x7F|
|~x \| ~y|0xDF|
|x & !y|0x00|
|x && y|0x01|
|x \|\| y|0x01|
|!x \|\| !y|0x00|
|x && ~y|0x01|
***
## 练习2.15
### 只使用位级和逻辑运算，编写一个C表达式，它等价于x==y。换句话说，当x和y相等时他将返回1，否则为0
```c
return (x^y)&&1;
```
***
## 练习2.16
### 填写下标，展示不同移位运算对单字节数的影响。思考以为运算的最好方式是使用二进制表示。将最初的值转换为二进制，执行以为运算，然后再转换回十六进制。每个答案都应该是8个二进制数字或者两个十六进制数字。
<table>
    <tr>
        <th colspan="2">x</th>
        <th colspan="2">x
            <<3</th>
                <th colspan="2">x>>2(逻辑)</th>
                <th colspan="2">x>>2(算术)</th>
    </tr>
    <tr>
        <td>十六进制</td>
        <td>二进制</td>
        <td>十六进制</td>
        <td>二进制</td>
        <td>十六进制</td>
        <td>二进制</td>
        <td>十六进制</td>
        <td>二进制</td>
    </tr>
    <tr>
        <td>0xC3</td>
        <td>1100 0011</td>
        <td>0x18</td>
        <td>0001 1000</td>
        <td>0x30</td>
        <td>0011 0000</td>
        <td>0xF0</td>
        <td>1111 0000</td>
    </tr>
    <tr>
        <td>0x75</td>
        <td>0111 0101</td>
        <td>0xA8</td>
        <td>1010 1000</td>
        <td>0x1D</td>
        <td>0001 1101</td>
        <td>0x1D</td>
        <td>0001 1101</td>
    </tr>
    <tr>
        <td>0x87</td>
        <td>1000 0111</td>
        <td>0x38</td>
        <td>0011 1000</td>
        <td>0x21</td>
        <td>0010 0001</td>
        <td>0xE1</td>
        <td>1110 0001</td>
    </tr>
    <tr>
        <td>0x66</td>
        <td>0110 0110</td>
        <td>0x30</td>
        <td>0011 0000</td>
        <td>0x19</td>
        <td>0001 1001</td>
        <td>0x19</td>
        <td>0001 1001</td>
    </tr>

</table>

***
## 练习2.17
### 假设w=4，我们能给每个可能的十六进制数字赋予一个数值，假设用一个无符号或者补码表示。请根据这些表示，通过写出等式(2.1)和等式(2.3)所示的求和公式中的2的非零次幂，填写下表:
<table>
    <tr>
        <th colspan="2">x</th>
        <th rowspan="2">B2U(x)</th>
        <th rowspan="2">B2T(x)</th>
    </tr>
    <tr>
        <th>十六进制</th>
        <th>二进制</th>
    </tr>
    <tr>
        <td>0xE</td>
        <td>1110</td>
        <td>14</td>
        <td>-2</td>
    </tr>
    <tr>
        <td>0x0</td>
        <td>0000</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>0x5</td>
        <td>0101</td>
        <td>5</td>
        <td>5</td>
    </tr>
    <tr>
        <td>0x8</td>
        <td>1000</td>
        <td>8</td>
        <td>-8</td>
    </tr>
    <tr>
        <td>0xD</td>
        <td>1101</td>
        <td>13</td>
        <td>-3</td>
    </tr>
    <tr>
        <td>0xF</td>
        <td>1111</td>
        <td>15</td>
        <td>-1</td>
    </tr>
</table>

***
## 练习2.19
### 利用你解答习题2.17时填写的表格，填写下列描述函数T2U的表格
|x|T2U(x)|
|:-:|:-:|
|-8|8|
|-3|13|
|-2|14|
|-1|15|
|0|0|
|5|5|
***