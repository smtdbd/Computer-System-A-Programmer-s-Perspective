
## 练习2.21
### 假设在采用补码运算的32位机器上对这些表达式求值，按照图2-19的格式填写下表，描述强制类型转换和关系运算的结果。
|表达式|类型|求值|
|:-:|:-:|:-:|
|-2147483647-1 == 2147483648U|无符号|1|
|-2147483647-1 < 2147483647|有符号|1|
|-2147483647-1U < 2147483647|无符号|0|
|-2147483647-1 < -2147483647|有符号|1|
|-2147483647-1U < -2147483647|无符号|1|
***
## 练习2.23
### 考虑下面的C函数
```c
int fun1(unsigned word){
  return (int) ((word << 24) >> 24);
}
int fun1(unsigned word){
  return  (((int)word << 24) >> 24);
}
```
假设在一个采用补码运算的机器上以32位程序来执行这些函数。还假设有符号值的右移是算术右移，而无符号数值的右移是逻辑右移。
* 填写下表，说明这些函数对几个实例参数的结果，你会发现用十六进制表示来做会更方便，只要记住十六进制数字8到F的最高有效位等于一。    

|w|fun1(w)|fun2(w)|
|:-:|:-:|:-:|
|0x00000076|0x00000076|0x00000076|
|0x87654321|0x00000021|0x00000021|
|0x000000C9|0x000000C9|0xFFFFFFC9|
|0xEDCBA987|0x00000087|0xFFFFFF87|
***
## 练习2.24
### 假设将一个4位数值(用十六进制数字0~F表示)阶段到一个3位数值(用十六进制数字0~7表示)。填写下标，根据哪些位模式的无符号和补码解释，说明这种截断对某些情况的结果。
<table>
    <tr>
        <th colspan="2">十六进制</th>
        <th colspan="2">无符号</th>
        <th colspan="2">补码</th>
    </tr>
    <tr>
        <td>原始值</td>
        <td>截断值</td>
        <td>原始值</td>
        <td>截断值</td>
        <td>原始值</td>
        <td>截断值</td>
    </tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>2</td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
    </tr>
    <tr>
        <td>9</td>
        <td>1</td>
        <td>9</td>
        <td>1</td>
        <td>-7</td>
        <td>1</td>
    </tr>
    <tr>
        <td>B</td>
        <td>3</td>
        <td>11</td>
        <td>3</td>
        <td>-5</td>
        <td>3</td>
    </tr>
    <tr>
        <td>F</td>
        <td>7</td>
        <td>15</td>
        <td>7</td>
        <td>-1</td>
        <td>-1</td>
    </tr>
</table>

***
## 练习2.25
### 考虑下列代码，这段代码试图计算数组a中所有元素的和